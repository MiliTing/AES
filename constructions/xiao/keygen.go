package xiao

import (
	"github.com/OpenWhiteBox/AES/primitives/matrix"

	"github.com/OpenWhiteBox/AES/constructions/common"
	"github.com/OpenWhiteBox/AES/constructions/saes"
)

// StandardAES form of Xiao-Lai:
//
// func (constr Construction) Encrypt(dst, src []byte) {
// 	roundKeys := constr.StretchedKey()
// 	copy(dst, src)
//
// 	for i := 0; i <= 9; i++ {
// 		constr.ShiftRows(roundKeys[i])
// 	}
//
// 	for i := 0; i < 9; i++ {
// 		constr.ShiftRows(dst)
// 		constr.AddRoundKey(roundKeys[i], dst)
// 		constr.SubBytes(dst)
// 		constr.MixColumns(dst)
// 	}
//
// 	constr.ShiftRows(dst)
// 	constr.AddRoundKey(roundKeys[9], dst)
// 	constr.SubBytes(dst)
// 	constr.AddRoundKey(roundKeys[10], dst)
// }

func sideFromPos(pos int) Side {
	if pos%4 < 2 {
		return Left
	} else {
		return Right
	}
}

// GenerateEncryptionKeys creates a white-boxed version of the AES key `key` for encryption, with any non-determinism
// generated by `seed`.
func GenerateEncryptionKeys(key, seed []byte, opts common.KeyGenerationOpts) (out Construction, inputMask, outputMask matrix.Matrix) {
	constr := saes.Construction{key}
	roundKeys := constr.StretchedKey()

	// Apply ShiftRows to round keys 0 to 9.
	for k := 0; k < 10; k++ {
		constr.ShiftRows(roundKeys[k])
	}

	// Generate input and output encodings.
	common.GenerateMasks(seed, opts, &inputMask, &outputMask)

	// Generate the round material for rounds 0 to 8.
	for round := 0; round < 9; round++ {
		out.ShiftRows[round] = ShiftRows.Compose(matrix.GenerateIdentity(128))

		for pos := 0; pos < 16; pos += 2 {
			out.TBoxMixCol[round][pos/2] = TBoxMixCol{
				[2]common.TBox{
					common.TBox{constr, roundKeys[round][pos+0], 0x00},
					common.TBox{constr, roundKeys[round][pos+1], 0x00},
				},
				sideFromPos(pos),
			}
		}
	}

	// Generate the round material for round 9.
	out.ShiftRows[9] = ShiftRows.Compose(matrix.GenerateIdentity(128))
	for pos := 0; pos < 16; pos += 2 {
		out.TBoxMixCol[9][pos/2] = TBox{
			[2]common.TBox{
				common.TBox{constr, roundKeys[9][pos+0], roundKeys[10][pos+0]},
				common.TBox{constr, roundKeys[9][pos+1], roundKeys[10][pos+1]},
			},
			sideFromPos(pos),
		}
	}

	// The first ShiftRows matrix should also remove the input mask.
	// We also need to apply a final matrix transformation to convert the double-level encoding to a block-level one.
	out.ShiftRows[0] = out.ShiftRows[0].Compose(inputMask)
	out.FinalMask = outputMask.Compose(matrix.GenerateIdentity(128))

	return out, inputMask, outputMask
}

// GenerateDecryptionKeys creates a white-boxed version of the AES key `key` for decryption, with any non-determinism
// generated by `seed`.
func GenerateDecryptionKeys(key, seed []byte) (out Construction, inputMask, outputMask matrix.Matrix) {
	panic("Decryption key generation isn't currently implemented!")
}
