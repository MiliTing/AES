package xiao

import (
	"github.com/OpenWhiteBox/AES/primitives/encoding"
	"github.com/OpenWhiteBox/AES/primitives/matrix"

	"github.com/OpenWhiteBox/AES/constructions/common"
	"github.com/OpenWhiteBox/AES/constructions/saes"
)

// StandardAES form of Xiao-Lai:
//
// func (constr Construction) Encrypt(dst, src []byte) {
// 	roundKeys := constr.StretchedKey()
// 	copy(dst, src)
//
// 	for i := 0; i <= 9; i++ {
// 		constr.ShiftRows(roundKeys[i])
// 	}
//
// 	for i := 0; i < 9; i++ {
// 		constr.ShiftRows(dst)
// 		constr.AddRoundKey(roundKeys[i], dst)
// 		constr.SubBytes(dst)
// 		constr.MixColumns(dst)
// 	}
//
// 	constr.ShiftRows(dst)
// 	constr.AddRoundKey(roundKeys[9], dst)
// 	constr.SubBytes(dst)
// 	constr.AddRoundKey(roundKeys[10], dst)
// }

// GenerateEncryptionKeys creates a white-boxed version of the AES key `key` for encryption, with any non-determinism
// generated by `seed`.
func GenerateEncryptionKeys(key, seed []byte, opts common.KeyGenerationOpts) (out Construction, inputMask, outputMask matrix.Matrix) {
	constr := saes.Construction{key}
	roundKeys := constr.StretchedKey()

	// Apply ShiftRows to round keys 0 to 9.
	for k := 0; k < 10; k++ {
		constr.ShiftRows(roundKeys[k])
	}

	// Generate input and output encodings.
	common.GenerateMasks(seed, opts, &inputMask, &outputMask)

	// Generate the round material for rounds 0 to 8.
	for round := 0; round < 9; round++ {
		if round == 0 { // The first ShiftRows matrix removes the input mask instead of another round's mask.
			out.ShiftRows[0] = MaskSwap(seed, 16, 0).Compose(ShiftRows).Compose(inputMask)
		} else {
			out.ShiftRows[round] = MaskSwap(seed, 16, round).Compose(ShiftRows).Compose(MaskSwap(seed, 32, round-1))
		}

		for pos := 0; pos < 16; pos += 2 {
			inEnc := common.MixingBijection(seed, 16, round, pos/2)
			outEnc := common.MixingBijection(seed, 32, round, pos/4)

			inInv, _ := inEnc.Invert()
			outInv, _ := outEnc.Invert()

			out.TBoxMixCol[round][pos/2] = encoding.DoubleToWordTable{
				encoding.DoubleLinear{inEnc, inInv},
				encoding.WordLinear{outInv, outEnc},
				TBoxMixCol{
					[2]common.TBox{
						common.TBox{constr, roundKeys[round][pos+0], 0x00},
						common.TBox{constr, roundKeys[round][pos+1], 0x00},
					},
					SideFromPos(pos),
				},
			}
		}
	}

	// Generate the round material for round 9.
	out.ShiftRows[9] = MaskSwap(seed, 16, 9).Compose(ShiftRows).Compose(MaskSwap(seed, 32, 8))

	for pos := 0; pos < 16; pos += 2 {
		inEnc := common.MixingBijection(seed, 16, 9, pos/2)
		outEnc := common.MixingBijection(seed, 32, 9, pos/4)

		inInv, _ := inEnc.Invert()
		outInv, _ := outEnc.Invert()

		out.TBoxMixCol[9][pos/2] = encoding.DoubleToWordTable{
			encoding.DoubleLinear{inEnc, inInv},
			encoding.WordLinear{outInv, outEnc},
			TBox{
				[2]common.TBox{
					common.TBox{constr, roundKeys[9][pos+0], roundKeys[10][pos+0]},
					common.TBox{constr, roundKeys[9][pos+1], roundKeys[10][pos+1]},
				},
				SideFromPos(pos),
			},
		}
	}

	// We need to apply a final matrix transformation to convert the double-level encoding to a block-level one.
	out.FinalMask = outputMask.Compose(MaskSwap(seed, 32, 9))

	return out, inputMask, outputMask
}

// GenerateDecryptionKeys creates a white-boxed version of the AES key `key` for decryption, with any non-determinism
// generated by `seed`.
func GenerateDecryptionKeys(key, seed []byte) (out Construction, inputMask, outputMask matrix.Matrix) {
	panic("Decryption key generation isn't currently implemented!")
}
