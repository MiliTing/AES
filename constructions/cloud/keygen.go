package cloud

import (
	"github.com/OpenWhiteBox/AES/primitives/encoding"
	"github.com/OpenWhiteBox/AES/primitives/matrix"
	"github.com/OpenWhiteBox/AES/primitives/table"

	"github.com/OpenWhiteBox/AES/constructions/common"
	"github.com/OpenWhiteBox/AES/constructions/saes"
)

type Transform struct {
	Input    [16]table.Byte
	Linear   matrix.Matrix
	Constant []byte
}

func generateMatrices(rs *common.RandomSource, inner []Transform) (out []Matrix) {
	size := len(inner)

	for round, trans := range inner {
		slices := [16]table.Block{}
		constant := split(rs, trans.Constant)

		for pos := 0; pos < 16; pos++ {
			slices[pos] = encoding.BlockTable{
				encoding.ComposedBytes{
					MixingBijection(rs, size, round-1, pos),
					ByteRoundEncoding(rs, size, round-1, pos),
				},
				BlockSliceEncoding(rs, size, round, pos),
				table.ComposedToBlock{
					Heads: trans.Input[pos],
					Tails: common.BlockMatrix{
						Linear:   trans.Linear,
						Constant: constant[pos],
						Position: pos,
					},
				},
			}
		}

		xors := common.BlockXORTables(
			SliceEncoding(rs, round),
			XOREncoding(rs, round),
			RoundEncoding(rs, size, round),
		)

		out = append(out, Matrix{slices, xors})
	}

	return
}

func generateAES(inputMask, outputMask *matrix.Matrix, roundKeys [11][]byte) []Transform {
	id, inv := [16]table.Byte{}, [16]table.Byte{}

	for pos := 0; pos < 16; pos++ {
		id[pos] = table.IdentityByte{}
		inv[pos] = Invert{}
	}

	out := []Transform{
		Transform{
			Input:    id,
			Linear:   *inputMask,
			Constant: roundKeys[0],
		},
	}

	for round := 1; round <= 9; round++ {
		out = append(out, Transform{
			Input:    inv,
			Linear:   Round,
			Constant: roundKeys[round],
		})
	}

	out = append(out, Transform{
		Input:    inv,
		Linear:   (*outputMask).Compose(LastRound),
		Constant: (*outputMask).Mul(matrix.Row(roundKeys[10])),
	})

	return out
}

// GenerateEncryptionKeys creates a white-boxed version of the AES key `key` for encryption, with any non-determinism
// generated by `seed`.  The `opts` specifies what type of input and output masks we put on the construction and should
// be either IndependentMasks, SameMasks, or MatchingMasks.
func GenerateEncryptionKeys(key, seed []byte, opts common.KeyGenerationOpts) (out Construction, inputMask, outputMask matrix.Matrix) {
	rs := common.NewRandomSource("Cloud Encryption", seed)

	constr := saes.Construction{key}
	roundKeys := constr.StretchedKey()

	for round := 1; round <= 10; round++ {
		for pos := 0; pos < 16; pos++ {
			roundKeys[round][pos] ^= SubBytesConst[pos]
		}
	}

	common.GenerateMasks(&rs, opts, &inputMask, &outputMask)

	aes := generateAES(&inputMask, &outputMask, roundKeys)

	out = generateMatrices(&rs, aes)

	return
}

// GenerateDecryptionKeys creates a white-boxed version of the AES key `key` for decryption, with any non-determinism
// generated by `seed`.  The `opts` argument works the same as above.
func GenerateDecryptionKeys(key, seed []byte, opts common.KeyGenerationOpts) (out Construction, inputMask, outputMask matrix.Matrix) {
	panic("Decryption key generation isn't implemented yet!")
}
