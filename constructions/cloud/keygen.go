package cloud

import (
	"github.com/OpenWhiteBox/AES/primitives/matrix"
	"github.com/OpenWhiteBox/AES/primitives/table"

	"github.com/OpenWhiteBox/AES/constructions/common"
	"github.com/OpenWhiteBox/AES/constructions/saes"
)

type Transform struct {
	Input    table.Byte
	Linear   matrix.Matrix
	Constant []byte
}

func generateMatrices(rs *common.RandomSource, inner []Transform) (out []Matrix) {
	for _, trans := range inner {
		slices := [16]table.Block{}
		constant := split(rs, trans.Constant)

		for pos := 0; pos < 16; pos++ {
			slices[pos] = table.ComposedToBlock{
				trans.Input,
				common.BlockMatrix{
					trans.Linear,
					constant[pos],
					pos,
				},
			}
		}

		out = append(out, Matrix{slices, blockXORTables()})
	}

	return
}

// GenerateEncryptionKeys creates a white-boxed version of the AES key `key` for encryption, with any non-determinism
// generated by `seed`.  The `opts` specifies what type of input and output masks we put on the construction and should
// be either IndependentMasks, SameMasks, or MatchingMasks.
func GenerateEncryptionKeys(key, seed []byte, opts common.KeyGenerationOpts) (out Construction, inputMask, outputMask matrix.Matrix) {
	rs := common.NewRandomSource("Cloud Encryption", seed)

	constr := saes.Construction{key}
	roundKeys := constr.StretchedKey()

	for round := 1; round <= 10; round++ {
		for pos := 0; pos < 16; pos++ {
			roundKeys[round][pos] ^= SubBytesConst[pos]
		}
	}

	common.GenerateMasks(&rs, opts, &inputMask, &outputMask)

	aes := []Transform{
		Transform{
			Input:    table.IdentityByte{},
			Linear:   inputMask,
			Constant: make([]byte, 16),
		},
		Transform{
			Input:    table.IdentityByte{},
			Linear:   matrix.GenerateIdentity(128),
			Constant: roundKeys[0],
		},
	}

	for round := 1; round <= 9; round++ {
		aes = append(aes, Transform{
			Input:    Invert{},
			Linear:   Round,
			Constant: roundKeys[round],
		})
	}

	aes = append(aes, Transform{
		Input:    Invert{},
		Linear:   LastRound,
		Constant: roundKeys[10],
	},
		Transform{
			Input:    table.IdentityByte{},
			Linear:   outputMask,
			Constant: make([]byte, 16),
		})

	out = generateMatrices(&rs, aes)

	return
}

// GenerateDecryptionKeys creates a white-boxed version of the AES key `key` for decryption, with any non-determinism
// generated by `seed`.  The `opts` argument works the same as above.
func GenerateDecryptionKeys(key, seed []byte, opts common.KeyGenerationOpts) (out Construction, inputMask, outputMask matrix.Matrix) {
	panic("Decryption key generation isn't implemented yet!")
}
