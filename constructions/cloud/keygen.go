package cloud

import (
	"github.com/OpenWhiteBox/AES/primitives/encoding"
	"github.com/OpenWhiteBox/AES/primitives/matrix"
	"github.com/OpenWhiteBox/AES/primitives/random"
	"github.com/OpenWhiteBox/AES/primitives/table"

	"github.com/OpenWhiteBox/AES/constructions/common"
	"github.com/OpenWhiteBox/AES/constructions/saes"
)

type Transform struct {
	Input    [16]table.Byte
	Linear   matrix.Matrix
	Constant [16]byte
}

func generateMatrices(rs *random.Source, inner []Transform) (out []Matrix) {
	size := len(inner)

	lastRound := [16]byte{}

	for round, trans := range inner {
		slices := [16]table.Block{}

		var constant [][16]byte
		if round < size-1 {
			constant = splitSecret(rs, trans.Constant, 17)
		} else {
			constant = splitSecret(rs, trans.Constant, 16)
		}

		for pos := 0; pos < 16; pos++ {
			slices[pos] = encoding.BlockTable{
				encoding.ComposedBytes{
					MixingBijection(rs, size, round-1, pos),
					ByteRoundEncoding(rs, size, round-1, pos),
				},
				BlockSliceEncoding(rs, size, round, pos),
				table.ComposedToBlock{
					Heads: table.ComposedBytes{AddTable(lastRound[pos]), trans.Input[pos]},
					Tails: common.BlockMatrix{
						Linear:   trans.Linear,
						Constant: constant[pos],
						Position: pos,
					},
				},
			}
		}

		xors := common.BlockXORTables(
			SliceEncoding(rs, round),
			XOREncoding(rs, round),
			RoundEncoding(rs, size, round),
		)

		out = append(out, Matrix{slices, xors})

		if round < size-1 {
			copy(lastRound[:], constant[16][:])
		}
	}

	return
}

// GenerateEncryptionKeys creates a white-boxed version of the AES key `key` for encryption, with any non-determinism
// generated by `seed`.  The `opts` specifies what type of input and output masks we put on the construction and should
// be either IndependentMasks, SameMasks, or MatchingMasks.
func GenerateEncryptionKeys(key, seed []byte, opts common.KeyGenerationOpts) (out Construction, inputMask, outputMask matrix.Matrix) {
	rs := random.NewSource("Cloud Encryption", seed)

	constr := saes.Construction{key}
	roundKeys := constr.StretchedKey()
	common.GenerateMasks(&rs, opts, &inputMask, &outputMask)

	for round := 1; round <= 10; round++ {
		for pos := 0; pos < 16; pos++ {
			roundKeys[round][pos] ^= SubBytesConst[pos]
		}
	}

	padding := RandomPaddingSizes(&rs, 10)
	aes := basicEncryption(&inputMask, &outputMask, roundKeys, padding)

	randomizeFieldInversions(&rs, aes, padding)

	out = generateMatrices(&rs, aes)

	return
}

// GenerateDecryptionKeys creates a white-boxed version of the AES key `key` for decryption, with any non-determinism
// generated by `seed`.  The `opts` argument works the same as above.
func GenerateDecryptionKeys(key, seed []byte, opts common.KeyGenerationOpts) (out Construction, inputMask, outputMask matrix.Matrix) {
	rs := random.NewSource("Cloud Decryption", seed)

	constr := saes.Construction{key}
	roundKeys := constr.StretchedKey()
	common.GenerateMasks(&rs, opts, &inputMask, &outputMask)

	for round := 9; round > 0; round-- {
		roundKeys[round] = UnRound.Mul(matrix.Row(roundKeys[round]))
	}
	roundKeys[10] = FirstRound.Mul(matrix.Row(roundKeys[10]))

	for round := 1; round <= 10; round++ {
		for pos := 0; pos < 16; pos++ {
			roundKeys[round][pos] ^= UnSubBytesConst[pos]
		}
	}

	padding := RandomPaddingSizes(&rs, 10)
	aes := basicDecryption(&inputMask, &outputMask, roundKeys, padding)

	randomizeFieldInversions(&rs, aes, padding)

	out = generateMatrices(&rs, aes)

	return
}
